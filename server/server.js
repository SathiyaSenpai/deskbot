/**
 * EMO Deskbot WebSocket Server
 * 
 * This server handles:
 * 1. Robot connection (ESP32)
 * 2. Browser/Phone control connections
 * 3. Real-time message relay between them
 * 4. AI Services (Chat, TTS)
 * 
 * Run: npm start
 * URL: http://localhost:3000
 */

import express from 'express';
import { WebSocketServer } from 'ws';
import http from 'http';
import path from 'path';
import { fileURLToPath } from 'url';
import { chat, textToSpeech, detectEmotion, AI_CONFIG } from './ai-services.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const PORT = process.env.PORT || 3000;

// ============================================================================
// CONFIGURATION
// ============================================================================

// Simple token auth (change this!)
const AUTH_TOKEN = 'emo_secret_2024';

// Robot state (broadcast to all controllers)
let robotState = {
  connected: false,
  currentBehavior: 'neutral',
  ledColor: { r: 0, g: 0, b: 0 },
  servoAngle: 90,
  lastSeen: null,
  sensors: {
    pir: false,
    ldr: 0,
    distance: 0,
    touch1: false,
    touch2: false
  }
};

// ============================================================================
// EXPRESS SETUP
// ============================================================================

app.use(express.json());

// Serve the full web UI (with chat and mic) from parent folder
app.use(express.static(path.join(__dirname, '..', 'web ui')));

// Serve mobile controller from /mobile
app.use('/mobile', express.static(path.join(__dirname, 'public')));

// Serve audio files generated by TTS
app.use('/audio', express.static(path.join(__dirname, 'audio')));

// Health check
app.get('/api/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    robotConnected: robotState.connected,
    aiConfig: {
      tts: AI_CONFIG.tts.engine,
      llm: AI_CONFIG.llm.engine,
      geminiConfigured: !!AI_CONFIG.llm.geminiApiKey
    }
  });
});

// Get robot state
app.get('/api/state', (req, res) => {
  res.json(robotState);
});

// ============================================================================
// AI CHAT ENDPOINT
// ============================================================================

app.post('/api/chat', async (req, res) => {
  try {
    const { message } = req.body;
    
    if (!message) {
      return res.status(400).json({ error: 'Message required' });
    }
    
    console.log('[Chat] User:', message);
    
    // Get AI response
    const response = await chat(message);
    console.log('[Chat] EMO:', response);
    
    // Detect emotion for robot expression
    const emotion = detectEmotion(message + ' ' + response);
    
    // Generate TTS audio (optional)
    let audio = null;
    try {
      audio = await textToSpeech(response);
    } catch (err) {
      console.log('[TTS] Skipped:', err.message);
    }
    
    // Send behavior change to robot
    if (robotState.connected && robotClient) {
      // Map emotions to actual ESP32 behavior names
      const behaviorMap = {
        happy: 'happy',
        sad: 'soft_sad',
        angry: 'startled', 
        surprised: 'startled',
        confused: 'listening_confused',
        sleepy: 'sleepy_idle',
        excited: 'playful_mischief',
        neutral: 'calm_idle',
        thinking: 'thinking',
        shy: 'shy_idle'
      };
      
      sendToRobot({ type: 'set_behavior', name: behaviorMap[emotion] || 'calm_idle' });
      
      // If we have audio, tell robot to play it
      if (audio && audio.audioFile) {
        sendToRobot({ type: 'play_audio', url: audio.audioFile });
      }
    }
    
    res.json({
      response,
      emotion,
      audio: audio?.audioFile || null
    });
    
  } catch (error) {
    console.error('[Chat] Error:', error);
    res.status(500).json({ error: 'Chat failed', message: error.message });
  }
});

// TTS endpoint
app.post('/api/tts', async (req, res) => {
  try {
    const { text } = req.body;
    
    if (!text) {
      return res.status(400).json({ error: 'Text required' });
    }
    
    const result = await textToSpeech(text);
    res.json(result);
    
  } catch (error) {
    console.error('[TTS] Error:', error);
    res.status(500).json({ error: 'TTS failed', message: error.message });
  }
});

// REST endpoint for simple commands (useful for testing)
app.post('/api/cmd', (req, res) => {
  const { token, cmd } = req.body;
  
  if (token !== AUTH_TOKEN) {
    return res.status(401).json({ error: 'Invalid token' });
  }
  
  if (!robotState.connected) {
    return res.status(503).json({ error: 'Robot not connected' });
  }
  
  // Send to robot
  if (robotClient && robotClient.readyState === 1) {
    robotClient.send(JSON.stringify(cmd));
    res.json({ success: true, sent: cmd });
  } else {
    res.status(503).json({ error: 'Robot WebSocket not ready' });
  }
});

// ============================================================================
// WEBSOCKET SETUP
// ============================================================================

const server = http.createServer(app);
const wss = new WebSocketServer({ server, path: '/ws' });

// Track clients
let robotClient = null;
const controllers = new Set();

// Broadcast to all controllers
function broadcastToControllers(data) {
  const message = JSON.stringify(data);
  controllers.forEach(client => {
    if (client.readyState === 1) {
      client.send(message);
    }
  });
}

// Send to robot
function sendToRobot(data) {
  if (robotClient && robotClient.readyState === 1) {
    robotClient.send(JSON.stringify(data));
    return true;
  }
  return false;
}

wss.on('connection', (ws, req) => {
  const url = new URL(req.url, `http://${req.headers.host}`);
  const token = url.searchParams.get('token');
  const clientType = url.searchParams.get('type'); // 'robot' or 'controller'
  
  console.log(`[WS] New connection: type=${clientType}`);
  
  // Validate token
  if (token !== AUTH_TOKEN) {
    console.log('[WS] Invalid token, closing connection');
    ws.close(4001, 'Invalid token');
    return;
  }
  
  // Register client
  if (clientType === 'robot') {
    // Only one robot allowed
    if (robotClient) {
      console.log('[WS] Robot already connected, closing old connection');
      robotClient.close();
    }
    robotClient = ws;
    robotState.connected = true;
    robotState.lastSeen = new Date().toISOString();
    
    console.log('[WS] Robot connected!');
    
    // Notify controllers
    broadcastToControllers({
      type: 'robot_status',
      connected: true,
      timestamp: robotState.lastSeen
    });
    
    // Send welcome to robot
    ws.send(JSON.stringify({
      type: 'welcome',
      message: 'Connected to server'
    }));
    
  } else {
    // Controller (browser/phone)
    controllers.add(ws);
    console.log(`[WS] Controller connected (total: ${controllers.size})`);
    
    // Send current state
    ws.send(JSON.stringify({
      type: 'init',
      robotConnected: robotState.connected,
      state: robotState
    }));
  }
  
  // Handle messages
  ws.on('message', (data) => {
    try {
      const msg = JSON.parse(data.toString());
      
      if (ws === robotClient) {
        // Message from robot
        handleRobotMessage(msg);
      } else {
        // Message from controller
        handleControllerMessage(msg, ws);
      }
    } catch (err) {
      console.error('[WS] Error parsing message:', err);
    }
  });
  
  // Handle disconnect
  ws.on('close', () => {
    if (ws === robotClient) {
      console.log('[WS] Robot disconnected');
      robotClient = null;
      robotState.connected = false;
      
      broadcastToControllers({
        type: 'robot_status',
        connected: false
      });
    } else {
      controllers.delete(ws);
      console.log(`[WS] Controller disconnected (remaining: ${controllers.size})`);
    }
  });
  
  ws.on('error', (err) => {
    console.error('[WS] Error:', err);
  });
});

// ============================================================================
// MESSAGE HANDLERS
// ============================================================================

function handleRobotMessage(msg) {
  console.log('[Robotâ†’Server]', msg.type || 'data');
  
  switch (msg.type) {
    case 'hello':
      // Robot initial hello message
      console.log('[Robot] Connected device:', msg.device, 'version:', msg.version);
      robotState.lastSeen = new Date().toISOString();
      break;
      
    case 'robot_status':
      // Robot status update
      robotState.currentBehavior = msg.behavior || robotState.currentBehavior;
      robotState.lastSeen = new Date().toISOString();
      broadcastToControllers({ type: 'robot_status', state: msg.state, behavior: msg.behavior });
      break;
      
    case 'sensor_data':
      // Sensor update from ESP32 (normalize for UI)
      robotState.sensors = {
        pir: msg.motion || false,
        ldr: msg.light || 0,
        distance_mm: msg.distance_mm || 0,
        touch1: msg.touch_head || false,
        touch2: msg.touch_side || false,
        sound: msg.sound || 0
      };
      robotState.lastSeen = new Date().toISOString();

      // Normalize keys to what the web UI expects
      const sensorsForUi = {
        light: robotState.sensors.ldr,
        motion: robotState.sensors.pir,
        sound: robotState.sensors.sound,
        touch: (robotState.sensors.touch1 || robotState.sensors.touch2) ? 'touched' : 'none',
        distance: robotState.sensors.distance_mm > 0 ? (robotState.sensors.distance_mm / 10.0) : null
      };

      broadcastToControllers({ type: 'sensor_update', sensors: sensorsForUi });
      break;
      
    case 'state':
      // Robot sending its state
      robotState = { ...robotState, ...msg.data };
      robotState.lastSeen = new Date().toISOString();
      broadcastToControllers({ type: 'state', state: robotState });
      break;
      
    case 'sensor':
      // Sensor update (legacy format)
      robotState.sensors = { ...robotState.sensors, ...msg.data };
      robotState.lastSeen = new Date().toISOString();
      broadcastToControllers({ type: 'sensor_update', sensors: robotState.sensors });
      break;
      
    case 'event':
      // Robot event (motion detected, touched, etc.)
      broadcastToControllers({ type: 'event', event: msg.event, details: msg.data });
      break;
      
    case 'pong':
      // Heartbeat response
      robotState.lastSeen = new Date().toISOString();
      break;
      
    default:
      // Forward unknown messages to controllers
      console.log('[Robot] Unknown message type:', msg.type);
      broadcastToControllers(msg);
  }
}

function handleControllerMessage(msg, ws) {
  console.log('[Controllerâ†’Server]', msg.type || 'cmd');
  
  switch (msg.type) {
    case 'behavior':
    case 'trigger_behavior':
      // Change expression/behavior
      const behaviorName = msg.name || msg.behavior;
      if (sendToRobot({ type: 'set_behavior', name: behaviorName })) {
        robotState.currentBehavior = behaviorName;
        broadcastToControllers({ type: 'behavior_change', behavior: behaviorName });
      }
      break;
      
    case 'led':
    case 'set_led':
      // Change LED color - handle both color string and RGB values
      let r = 0, g = 0, b = 0;
      if (msg.color) {
        // Parse hex color string
        const color = msg.color.replace('#', '');
        if (color === 'off') {
          r = g = b = 0;
        } else {
          r = parseInt(color.substr(0, 2), 16) || 0;
          g = parseInt(color.substr(2, 2), 16) || 0;
          b = parseInt(color.substr(4, 2), 16) || 0;
        }
      } else {
        r = msg.r || 0;
        g = msg.g || 0;
        b = msg.b || 0;
      }
      if (sendToRobot({ type: 'set_led', r, g, b })) {
        robotState.ledColor = { r, g, b };
        const colorHex = (r === 0 && g === 0 && b === 0)
          ? 'off'
          : `#${[r, g, b].map(v => v.toString(16).padStart(2, '0')).join('')}`;
        broadcastToControllers({ type: 'led_state', color: colorHex });
      }
      break;
      
    case 'servo':
    case 'set_servo':
      // Move servo
      if (sendToRobot({ type: 'set_servo', angle: msg.angle })) {
        robotState.servoAngle = msg.angle;
      }
      break;
      
    case 'tts':
      // Text-to-speech (future)
      sendToRobot({ type: 'tts', text: msg.text });
      break;
      
    case 'audio':
      // Play audio
      sendToRobot({ type: 'play_audio', url: msg.url });
      break;
      
    case 'raw':
      // Send raw command to robot
      sendToRobot(msg.cmd);
      break;
      
    case 'ping':
      // Heartbeat
      ws.send(JSON.stringify({ type: 'pong' }));
      break;
      
    default:
      // Forward to robot
      sendToRobot(msg);
  }
}

// ============================================================================
// HEARTBEAT
// ============================================================================

// Ping robot every 30 seconds
setInterval(() => {
  if (robotClient && robotClient.readyState === 1) {
    robotClient.send(JSON.stringify({ type: 'ping' }));
  }
}, 30000);

// ============================================================================
// START SERVER
// ============================================================================

server.listen(PORT, '0.0.0.0', () => {
  console.log('');
  console.log('ðŸ¤– EMO Deskbot Server Started!');
  console.log('================================');
  console.log(`   Full UI:  http://localhost:${PORT}  (Chat + Mic)`);
  console.log(`   Mobile:   http://localhost:${PORT}/mobile  (Quick Controls)`);
  console.log('');
  console.log('WebSocket:');
  console.log(`   Robot:      ws://localhost:${PORT}/ws?type=robot&token=${AUTH_TOKEN}`);
  console.log(`   Controller: ws://localhost:${PORT}/ws?type=controller&token=${AUTH_TOKEN}`);
  console.log('');
  console.log('API Endpoints:');
  console.log(`   GET  /api/health - Server health check`);
  console.log(`   GET  /api/state  - Get robot state`);
  console.log(`   POST /api/chat   - Chat with EMO (AI)`);
  console.log(`   POST /api/tts    - Text to Speech`);
  console.log(`   POST /api/cmd    - Send command to robot`);
  console.log('');
  console.log('AI Status:');
  console.log(`   TTS Engine: ${AI_CONFIG.tts.engine}`);
  console.log(`   LLM Engine: ${AI_CONFIG.llm.engine}`);
  console.log(`   Gemini Key: ${AI_CONFIG.llm.geminiApiKey ? 'âœ“ Configured' : 'âœ— Not set (using fallback)'}`);
  console.log('');
  console.log('Waiting for robot connection...');
  console.log('');
});
